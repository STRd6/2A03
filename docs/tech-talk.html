<!DOCTYPE html>

<html>
<head>
  <title>tech-talk</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="https://strd6.github.io/cdn/parallel/docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    <ul class="sections">
      <li id="section-1">
  <div class="annotation">
    <div class="pilwrap">
      <a class="pilcrow" href="#section-1">&#182;</a>
    </div>
    <h1 id="midi-chlorian">MIDI Chlorian</h1>

  </div>
  <div class="content"><pre><code>
</code></pre>
</div>
</li>
<li id="section-2">
  <div class="annotation">
    <div class="pilwrap">
      <a class="pilcrow" href="#section-2">&#182;</a>
    </div>
    <p>Deconstructing the world&#39;s best online MIDI player.</p>
<h2 id="wtf-is-midis-">WTF is MIDIs?</h2>

  </div>
  <div class="content"><pre><code>
</code></pre>
</div>
</li>
<li id="section-3">
  <div class="annotation">
    <div class="pilwrap">
      <a class="pilcrow" href="#section-3">&#182;</a>
    </div>
    <p>MIDI (/ˈmɪdi/; short for Musical Instrument Digital Interface) is a technical standard that 
describes a protocol, digital interface and connectors and allows a wide variety 
of electronic musical instruments, computers and other related devices to connect 
and communicate with one another. A single MIDI link can carry up to sixteen 
channels of information, each of which can be routed to a separate device.</p>
<ul>
<li><a href="http://oktopus.hu/uploaded/Tudastar/MIDI%201.0%20Detailed%20Specification.pdf">MIDI Specification</a></li>
<li><a href="https://www.midi.org/specifications/item/table-1-summary-of-midi-message">MIDI Message Summary</a></li>
</ul>
<h2 id="wtf-is-sound-fonts-">WTF is Sound Fonts?</h2>

  </div>
  <div class="content"><pre><code>
</code></pre>
</div>
</li>
<li id="section-4">
  <div class="annotation">
    <div class="pilwrap">
      <a class="pilcrow" href="#section-4">&#182;</a>
    </div>
    <p>MIDI files do not contain any sounds, only instructions to play them. Sound Fonts
contain information about how instruments sound and how those sounds evolve over time.</p>
<p>Sound Fonts encode all the data required to produce a sound including pitch, intonation,
expressiveness, timbre, and more.</p>
<p>You can imagine MIDI like being sheet music and a Sound Font like being an orchestra,
or storehouse of musical instruments.</p>
<p>If you put them both together in software you can play music!</p>
<ul>
<li><a href="http://freepats.zenvoid.org/sf2/sfspec24.pdf">Sound Font Technical Specification</a></li>
<li><a href="https://github.com/colinbdclark/sf2-parser">SF2 Parser</a></li>
<li><a href="https://github.com/gree/sf2synth.js">SF2 Synth</a></li>
</ul>
<h2 id="what-the-crap-is-web-audio-">What the crap is Web Audio?</h2>

  </div>
  <div class="content"><pre><code>
</code></pre>
</div>
</li>
<li id="section-5">
  <div class="annotation">
    <div class="pilwrap">
      <a class="pilcrow" href="#section-5">&#182;</a>
    </div>
    <p>In the browsers we have a few ways to play sounds. We can use the <code>&lt;audio&gt;</code> tag,
and programatically call things like <code>.play()</code> and <code>.pause()</code>. This is fine, but
it is very limited if we want to be able to play a wide range of sounds, we&#39;d
need a separate sample for every note. Effects like pitch bends, reverb, panning,
etc. would be impossible.</p>
<p>Enter the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API">Web Audio API</a>.
The Web Audio API provides ways to creat the digital audio workstation of your dreams.
You can use waveform generators to create sounds, read sound data from buffers,
schedule sounds to play with high precision and low latency, connect audio nodes
to a vast array of effect nodes including volume, reverb, panning, and more.</p>
<p>We finally can play MIDIs the way they were meant to be played.</p>
<h2 id="putting-it-all-together">Putting it all Together</h2>

  </div>
  <div class="content"><pre><code>
</code></pre>
</div>
</li>
<li id="section-6">
  <div class="annotation">
    <div class="pilwrap">
      <a class="pilcrow" href="#section-6">&#182;</a>
    </div>
    <p>To read the binary Sound Font data we use a JS SoundFont parser created by GREE
and extended by Colin Clark. The role of the parser is to provide a JS interface
to all that sweet sweet instrument data that is trappend inside ones and zeros.</p>
<p>There&#39;s another half to the SoundFont reading, now that we have it in JS we still
need to turn it into sounds. For this I used SF2 Synth which maps the JS interface
into a network of WebAudio nodes in response to note events. This is what plays
the sounds that we&#39;ll hear.</p>
<p>Likewise we read the MIDI data into JS so that we can connect it up and have it 
control the synthesizer.</p>
<p>The player is composed of a <code>track controller</code> and a <code>synthesizer</code>. The track 
controller reads track events from the MIDI. It updates its  internal state 
and sends instructions to the synthesizer to control the sound output.</p>
<p>Because computers aren&#39;t magical and JS timing isn&#39;t 100% certain, we need to 
buffer the upcoming 0.25s - 2s of upcoming sounds so that we experience a smooth
playback experience.</p>
<p>We have an interval running as fast as the browser allows that checks to make sure
we&#39;re filling the upcoming buffer enough that we don&#39;t run out and stutter. Each 
update we pull off events from the MIDI until we&#39;ve filled out our upcoming sound
buffer.</p>
<p>The end result is sweet, beautiful music!</p>

  </div>
  <div class="content"><pre><code>
</code></pre>
</div>
</li>
    </ul>
  </div>
  <script src="https://code.jquery.com/jquery-1.10.1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js"></script><script>
  (function() {
  var ErrorReporter, bindUpdates, createEditor, exec, findInteractiveElements, readShebang, runners;

  createEditor = function(code, shebang, section) {
    var annotationElement, contentElement, editorElement, exampleSection, runtimeElement;
    exampleSection = $("<li>", {
      "class": "example"
    });
    annotationElement = $("<div>", {
      "class": "annotation"
    });
    editorElement = $("<textarea>", {
      "class": "annotation",
      text: code
    });
    contentElement = $("<div>", {
      "class": "content"
    });
    runtimeElement = $("<div>", {
      "class": "output"
    });
    contentElement.append(runtimeElement);
    annotationElement.append(editorElement);
    exampleSection.append(annotationElement);
    exampleSection.append(contentElement);
    section.after(exampleSection);
    return bindUpdates(shebang, editorElement, runtimeElement);
  };

  bindUpdates = function(shebang, editorElement, runtimeElement) {
    return editorElement.on("keyup", function() {
      var e, report, source;
      report = ErrorReporter(editorElement);
      source = editorElement.val();
      try {
        runners[shebang]({
          editorElement: editorElement,
          source: source,
          runtimeElement: runtimeElement
        });
        return report.clear();
      } catch (_error) {
        e = _error;
        return report(e);
      }
    });
  };

  readShebang = function(source) {
    var match;
    if (match = source.match(/^\#\! (.*)\n/)) {
      return match[1];
    }
  };

  ErrorReporter = function(editor) {
    var reporter;
    reporter = function(error) {
      var errorParagraph;
      if (editor.next().is("p.error")) {
        return editor.next().text(error);
      } else {
        errorParagraph = $("<p>", {
          "class": "error",
          text: error.toString()
        });
        return editor.after(errorParagraph);
      }
    };
    reporter.clear = function() {
      if (editor.next().is("p.error")) {
        return editor.next().remove();
      }
    };
    return reporter;
  };

  findInteractiveElements = function() {
    return $("blockquote > pre > code").each(function() {
      var blockQuoteElement, code, codeElement, sectionElement, shebang;
      codeElement = $(this);
      code = codeElement.text();
      if (shebang = readShebang(code)) {
        if (!runners[shebang]) {
          return;
        }
        code = code.split("\n").slice(1).join("\n");
        blockQuoteElement = codeElement.parent().parent();
        sectionElement = blockQuoteElement.parent().parent();
        blockQuoteElement.remove();
        return createEditor(code, shebang, sectionElement);
      }
    });
  };

  runners = {};

  (typeof window !== "undefined" && window !== null ? window : global).Interactive = {
    register: function(name, runner) {
      runners[name] = runner;
      findInteractiveElements();
      return $('#container').on('keyup', 'textarea', function() {
        $(this).height(0);
        return $(this).height(this.scrollHeight);
      }).find('textarea').keyup();
    }
  };

  exec = function(_arg) {
    var code, editorElement, runtimeElement, source;
    source = _arg.source, code = _arg.code, editorElement = _arg.editorElement, runtimeElement = _arg.runtimeElement;
    runtimeElement.remove();
    editorElement.replaceWith($("<pre>", {
      text: source
    }));
    return setTimeout(function() {
      return Function(code)();
    }, 0);
  };

  $(function() {
    Interactive.register("setup", function(params) {
      params.code = CoffeeScript.compile(params.source);
      return exec(params);
    });
    return Interactive.register("setup-js", function(params) {
      params.code = params.source;
      return exec(params);
    });
  });

}).call(this);

</script><script src="package.js"></script>
</body>
</html>